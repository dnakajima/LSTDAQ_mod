\hypertarget{structs_ring_buffer}{}\section{s\+Ring\+Buffer Struct Reference}
\label{structs_ring_buffer}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
int \hyperlink{structs_ring_buffer_a86973832a168fb3fb15847da4407e590}{s\+R\+Bid}
\begin{DoxyCompactList}\small\item\em Ring\+Buffer\+I\+D. \end{DoxyCompactList}\item 
int \hyperlink{structs_ring_buffer_ac518da2b168acdf6876786ad38465d3d}{Cid}
\begin{DoxyCompactList}\small\item\em Collector I\+D. \end{DoxyCompactList}\item 
char \hyperlink{structs_ring_buffer_a3d8b0121e3a6f4c1657581c5446e67cc}{sz\+Addr} \mbox{[}18\mbox{]}
\begin{DoxyCompactList}\small\item\em I\+P address of target F\+E\+B. \end{DoxyCompactList}\item 
unsigned short \hyperlink{structs_ring_buffer_a38ec2d7373bbb5e89f7282c3de49e564}{sh\+Port}
\begin{DoxyCompactList}\small\item\em port number of target F\+E\+B. \end{DoxyCompactList}\item 
\hyperlink{class_l_s_t_d_a_q_1_1_ring_buffer}{L\+S\+T\+D\+A\+Q\+::\+Ring\+Buffer} $\ast$ \hyperlink{structs_ring_buffer_a02e62b51275c98f3e74e6b04d9f3ecb6}{rb}
\item 
\hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} $\ast$ \hyperlink{structs_ring_buffer_a3685b679b0732b84bbccb1f467638ea9}{next}
\end{DoxyCompactItemize}


\subsection{Detailed Description}

\begin{DoxyParams}{Parameters}
{\em s\+R\+Bid} & Ring\+Buffer\+I\+D.\\
\hline
{\em Cid} & Collector I\+D. This is used to specify which collector thread controls the s\+Ring\+Buffer object. \\
\hline
{\em sz\+Addr} & Destination I\+P address of connection to F\+E\+B.\\
\hline
{\em sh\+Port} & Destination Port number of connection to F\+E\+B.\\
\hline
\end{DoxyParams}
\hypertarget{structs_ring_buffer_SRB_OVERVIEW}{}\subsection{Overview}\label{structs_ring_buffer_SRB_OVERVIEW}
This struct stores all information about an connection to F\+E\+B. They are created in \hyperlink{_master_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main()} function, based on Connection.\+conf, and used in \hyperlink{_master_8cpp_a568c34b708bcc89579bda6142733110a}{Collector\+\_\+thread()} and \hyperlink{_master_8cpp_a435b26afa480ba18cbef3620d0eccee2}{Builder\+\_\+thread()}.

\hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} has one-\/to-\/one correspondence to Ring\+Buffer object and connection to F\+E\+B. Therefore one \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct represents a connection to a F\+E\+B, and as many \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} structs as the connections to F\+E\+B are prepared. And it has one Ring\+Buffer object, which store all the data from a F\+E\+B temporally in a unit of event length. The purpose of this is to absorb timing inequality between connections, because the data-\/flows from F\+E\+Bs are not physically parallel.

A \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct belongs to a Collector\+\_\+thread, while a Collector\+\_\+thread can take care of multiple s\+R\+Bs. The relation between them is specified in Connection.\+conf by users and set in \hyperlink{_master_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main()} function.

A Collector\+\_\+thread performs data acquisition from F\+E\+Bs, reading data from sockets arrived by T\+C\+P connection and writing it on Ring\+Buffers.

The data stored in Ring\+Buffer is extracted one by one by Builder\+\_\+thread.\hypertarget{structs_ring_buffer_SRB_PROC}{}\subsection{Procedues}\label{structs_ring_buffer_SRB_PROC}
A \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct is used as follows.\hypertarget{structs_ring_buffer_SRB_CREATION}{}\subsubsection{main() -\/-\/-\/ Object creation}\label{structs_ring_buffer_SRB_CREATION}
In \hyperlink{_master_8cpp_a3c04138a5bfe5d72780bb7e82a18e627}{main()} function, s\+R\+Bs are created and the primal information to control them are set with \hyperlink{_master_8cpp_afdfe90600cb22da97e4a38a3a7245c0d}{s\+R\+Binit()}, \hyperlink{_master_8cpp_a2bc96e14aff905cfba14c80aa9fc6bc1}{s\+R\+Bcreate()} and \hyperlink{_master_8cpp_add67bfd9f7cbc6a394d0d61a41e57ec5}{s\+R\+Bsetaddr()}. When threads are created, the addresses of these s\+R\+Bs are given to the Collector\+\_\+threads and the Builder\+\_\+thread.\hypertarget{structs_ring_buffer_SRB_COLL}{}\subsubsection{Collector\+\_\+thread() -\/-\/-\/ Data acquisition}\label{structs_ring_buffer_SRB_COLL}
To identify Collector\+\_\+thread, Cid is set from the \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct given to the Collector\+\_\+thread. Then the thread decides which \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} to take care of, searching for the same Cid number. T\+C\+P/\+I\+P connections to F\+E\+Bs for \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} structs are also established, using the connection information stored in \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct.

In endless loop, data is extracted from socket and written on Ring\+Buffer object in \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} struct.\hypertarget{structs_ring_buffer_SRB_BLD}{}\subsubsection{Builder\+\_\+thread() -\/-\/-\/ Event building}\label{structs_ring_buffer_SRB_BLD}
\hyperlink{_master_8cpp_a435b26afa480ba18cbef3620d0eccee2}{Builder\+\_\+thread()} performs event building in which the data from all F\+E\+Bs is combined together to make a image of whole camera. Therefore it collects addresses of all \hyperlink{structs_ring_buffer}{s\+Ring\+Buffer} structs in the beginning. Then using read() function in Ring\+Buffer object, it collects data. 

\subsection{Member Data Documentation}
\hypertarget{structs_ring_buffer_ac518da2b168acdf6876786ad38465d3d}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!Cid@{Cid}}
\index{Cid@{Cid}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{Cid}]{\setlength{\rightskip}{0pt plus 5cm}int s\+Ring\+Buffer\+::\+Cid}\label{structs_ring_buffer_ac518da2b168acdf6876786ad38465d3d}


Collector I\+D. 

\hypertarget{structs_ring_buffer_a3685b679b0732b84bbccb1f467638ea9}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!next@{next}}
\index{next@{next}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{next}]{\setlength{\rightskip}{0pt plus 5cm}{\bf s\+Ring\+Buffer}$\ast$ s\+Ring\+Buffer\+::next}\label{structs_ring_buffer_a3685b679b0732b84bbccb1f467638ea9}
\hypertarget{structs_ring_buffer_a02e62b51275c98f3e74e6b04d9f3ecb6}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!rb@{rb}}
\index{rb@{rb}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{rb}]{\setlength{\rightskip}{0pt plus 5cm}{\bf L\+S\+T\+D\+A\+Q\+::\+Ring\+Buffer}$\ast$ s\+Ring\+Buffer\+::rb}\label{structs_ring_buffer_a02e62b51275c98f3e74e6b04d9f3ecb6}
\hypertarget{structs_ring_buffer_a38ec2d7373bbb5e89f7282c3de49e564}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!sh\+Port@{sh\+Port}}
\index{sh\+Port@{sh\+Port}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{sh\+Port}]{\setlength{\rightskip}{0pt plus 5cm}unsigned short s\+Ring\+Buffer\+::sh\+Port}\label{structs_ring_buffer_a38ec2d7373bbb5e89f7282c3de49e564}


port number of target F\+E\+B. 

for example, 24. The value in Connection.\+conf will be read and set. \hypertarget{structs_ring_buffer_a86973832a168fb3fb15847da4407e590}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!s\+R\+Bid@{s\+R\+Bid}}
\index{s\+R\+Bid@{s\+R\+Bid}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{s\+R\+Bid}]{\setlength{\rightskip}{0pt plus 5cm}int s\+Ring\+Buffer\+::s\+R\+Bid}\label{structs_ring_buffer_a86973832a168fb3fb15847da4407e590}


Ring\+Buffer\+I\+D. 

\hypertarget{structs_ring_buffer_a3d8b0121e3a6f4c1657581c5446e67cc}{}\index{s\+Ring\+Buffer@{s\+Ring\+Buffer}!sz\+Addr@{sz\+Addr}}
\index{sz\+Addr@{sz\+Addr}!s\+Ring\+Buffer@{s\+Ring\+Buffer}}
\subsubsection[{sz\+Addr}]{\setlength{\rightskip}{0pt plus 5cm}char s\+Ring\+Buffer\+::sz\+Addr\mbox{[}18\mbox{]}}\label{structs_ring_buffer_a3d8b0121e3a6f4c1657581c5446e67cc}


I\+P address of target F\+E\+B. 

for example, \char`\"{}192.\+168.\+10.\+1\char`\"{}. The value in Connection.\+conf will be read and set. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{_master_8cpp}{Master.\+cpp}\end{DoxyCompactItemize}
