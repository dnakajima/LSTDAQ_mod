<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>“LSTDAQ”: Master.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">“LSTDAQ”
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Master.cpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains main function.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;fstream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &quot;<a class="el" href="_ring_buffer_8hpp_source.html">RingBuffer.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_t_c_p_client_socket_8hpp_source.html">TCPClientSocket.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_d_a_qtimer_8hpp_source.html">DAQtimer.hpp</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="_config_8hpp_source.html">Config.hpp</a>&quot;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;sys/timerfd.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs_ring_buffer.html">sRingBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0662c9c05b645484787c418b871abfc5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a0662c9c05b645484787c418b871abfc5">DAQ_NEVENT</a>&#160;&#160;&#160;100000</td></tr>
<tr class="memdesc:a0662c9c05b645484787c418b871abfc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of events to acquire when NOT specified by user.  <a href="#a0662c9c05b645484787c418b871abfc5">More...</a><br /></td></tr>
<tr class="separator:a0662c9c05b645484787c418b871abfc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0173e926c090810e7a7f5cd30356192c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a0173e926c090810e7a7f5cd30356192c">inverseByteOrder</a> (char *buf, int bufsize)</td></tr>
<tr class="memdesc:a0173e926c090810e7a7f5cd30356192c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the byte order of given array.  <a href="#a0173e926c090810e7a7f5cd30356192c">More...</a><br /></td></tr>
<tr class="separator:a0173e926c090810e7a7f5cd30356192c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b0d9ec5f71e9be9d0520a7f862a486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#aa7b0d9ec5f71e9be9d0520a7f862a486">usage</a> (char *argv)</td></tr>
<tr class="separator:aa7b0d9ec5f71e9be9d0520a7f862a486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfe90600cb22da97e4a38a3a7245c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#afdfe90600cb22da97e4a38a3a7245c0d">sRBinit</a> ()</td></tr>
<tr class="separator:afdfe90600cb22da97e4a38a3a7245c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc96e14aff905cfba14c80aa9fc6bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a2bc96e14aff905cfba14c80aa9fc6bc1">sRBcreate</a> (int nServ)</td></tr>
<tr class="separator:a2bc96e14aff905cfba14c80aa9fc6bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add67bfd9f7cbc6a394d0d61a41e57ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#add67bfd9f7cbc6a394d0d61a41e57ec5">sRBsetaddr</a> (int sRBid, unsigned short shCid, char *szAddr, unsigned short shPort)</td></tr>
<tr class="separator:add67bfd9f7cbc6a394d0d61a41e57ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb25131ecbe5f55819aa31d331c833a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a5cb25131ecbe5f55819aa31d331c833a">getMaxCid</a> ()</td></tr>
<tr class="separator:a5cb25131ecbe5f55819aa31d331c833a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d162cd44c490ccae81ac5d22f7db74a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a6d162cd44c490ccae81ac5d22f7db74a">sRBdelete</a> (int nServ)</td></tr>
<tr class="separator:a6d162cd44c490ccae81ac5d22f7db74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9138383c988375a04ce17786819665e5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a9138383c988375a04ce17786819665e5">ThruPutMes_thread</a> (void *arg)</td></tr>
<tr class="memdesc:a9138383c988375a04ce17786819665e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ThruPutMes thread.  <a href="#a9138383c988375a04ce17786819665e5">More...</a><br /></td></tr>
<tr class="separator:a9138383c988375a04ce17786819665e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568c34b708bcc89579bda6142733110a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a568c34b708bcc89579bda6142733110a">Collector_thread</a> (void *arg)</td></tr>
<tr class="memdesc:a568c34b708bcc89579bda6142733110a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collector_thread Collects data from FEBs by TCP/IP connection and stores it to RingBuffer.  <a href="#a568c34b708bcc89579bda6142733110a">More...</a><br /></td></tr>
<tr class="separator:a568c34b708bcc89579bda6142733110a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435b26afa480ba18cbef3620d0eccee2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a435b26afa480ba18cbef3620d0eccee2">Builder_thread</a> (void *arg)</td></tr>
<tr class="memdesc:a435b26afa480ba18cbef3620d0eccee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder_thread Performs event building in which data is collected from all RingBuffers by event wise and is combined.  <a href="#a435b26afa480ba18cbef3620d0eccee2">More...</a><br /></td></tr>
<tr class="separator:a435b26afa480ba18cbef3620d0eccee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
<tr class="memdesc:a3c04138a5bfe5d72780bb7e82a18e627"><td class="mdescLeft">&#160;</td><td class="mdescRight">main  <a href="#a3c04138a5bfe5d72780bb7e82a18e627">More...</a><br /></td></tr>
<tr class="separator:a3c04138a5bfe5d72780bb7e82a18e627"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a44ff404ab6caa6e80830e799d22120a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a44ff404ab6caa6e80830e799d22120a0">infreq</a></td></tr>
<tr class="separator:a44ff404ab6caa6e80830e799d22120a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ca370ae9c3da6cf6d5e75206dfb76d"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a80ca370ae9c3da6cf6d5e75206dfb76d">Ndaq</a></td></tr>
<tr class="separator:a80ca370ae9c3da6cf6d5e75206dfb76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4fa43841449af20dd3798e7de87d2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a6e4fa43841449af20dd3798e7de87d2f">datacreate</a></td></tr>
<tr class="separator:a6e4fa43841449af20dd3798e7de87d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898fdbfa9c296c6a8e343c764f11acba"><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a898fdbfa9c296c6a8e343c764f11acba">mutex_initLock</a> =PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:a898fdbfa9c296c6a8e343c764f11acba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae415d43f6dfaf58e6bca992b143ac004"><td class="memItemLeft" align="right" valign="top">pthread_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#ae415d43f6dfaf58e6bca992b143ac004">cond_allend</a> =PTHREAD_COND_INITIALIZER</td></tr>
<tr class="separator:ae415d43f6dfaf58e6bca992b143ac004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae5c06802ed8788fbd5a7d55d9c5b85"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a4ae5c06802ed8788fbd5a7d55d9c5b85">initEnd</a></td></tr>
<tr class="separator:a4ae5c06802ed8788fbd5a7d55d9c5b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601520f53e2d3d67744513d176ccf90a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#a601520f53e2d3d67744513d176ccf90a">Ncpu</a></td></tr>
<tr class="separator:a601520f53e2d3d67744513d176ccf90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65708d975d0c62e4d1edb504fa5ba2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structs_ring_buffer.html">sRingBuffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_master_8cpp.html#aa65708d975d0c62e4d1edb504fa5ba2b">sRB</a> [<a class="el" href="_config_8hpp.html#a17300200b36fc0300d37054428db318b">MAX_RINGBUF</a>]</td></tr>
<tr class="separator:aa65708d975d0c62e4d1edb504fa5ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file contains main function. </p>
<p>main function reads configuration file and creates the threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Ndaq</td><td>will be aaa </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a0662c9c05b645484787c418b871abfc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DAQ_NEVENT&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of events to acquire when NOT specified by user. </p>
<p>Ndaq is set to this value as default value. And if specified - </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a435b26afa480ba18cbef3620d0eccee2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Builder_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builder_thread Performs event building in which data is collected from all RingBuffers by event wise and is combined. </p>
<h1><a class="anchor" id="BLD_PROC"></a>
The procedures</h1>
<ol type="1">
<li>Make lists of Ring Buffers.</li>
<li>sets CPU.</li>
<li>Output File Creation</li>
<li>Synchronizes with all threads before starting DAQ.</li>
<li>Read Data From RingBuffer with event building</li>
<li>Goes out the loop.</li>
<li>Writes summary report of DAQ.</li>
<li>Thread ends.</li>
</ol>
<h2><a class="anchor" id="BLD_RBLIST"></a>
Make lists of Ring Buffers.</h2>
<p>Arg is interpreted as the first <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> struct. Using <a class="el" href="structs_ring_buffer.html#a3685b679b0732b84bbccb1f467638ea9">sRingBuffer.next</a>, all sRingBuffers which will be used are collected.</p>
<h2><a class="anchor" id="BLD_SETCPU"></a>
Sets CPU</h2>
<p>Sets CPU. See <a class="el" href="index.html#CPU_ID">CPU ID specification</a> .</p>
<h2><a class="anchor" id="BLD_SEARCHRB"></a>
Search the charged sRingBuffer structs</h2>
<p>Searches all the structs for connections for which this thread is assigned.</p>
<h2><a class="anchor" id="BLD_OUTFILE_OPEN"></a>
Output File Creation</h2>
<p>Prepares the outputfile.</p>
<h2><a class="anchor" id="BLD_STARTSYNC"></a>
Synchronizes threads before starting DAQ.</h2>
<p>Waits for the other threads to be prepared as well. See <a class="el" href="index.html#START_SYNC">Start synchronization</a>. Just after this step, <a class="el" href="class_l_s_t_d_a_q_1_1_d_a_qtimer.html">LSTDAQ::DAQtimer</a> object is created to measure DAQ performance.</p>
<h2><a class="anchor" id="BLD_READ_DATA"></a>
Read Data From RingBuffer with build</h2>
<p>The loop procedue of reading data and performing event building.</p><ul>
<li>reading data<br />
 Data from all the FEBs are collected by reading data stored in all RingBuffers. This procedure is performed by <a class="el" href="class_l_s_t_d_a_q_1_1_ring_buffer.html#a589fb1045d27590cca235e01f313d1e8" title="The function to read data from RingBuffer. ">LSTDAQ::RingBuffer::read()</a> function, which reads data from each RingBuffer by event wise.</li>
<li>event building<br />
 The data from all RingBuffer is combined to one data array as one event data for whole camera. The data to be combined must have the result of identical trigger. This process makes sure the trigger is identical, investigating if trigger number is the same. Trigger number is extracted from data and are checked. If it is not the same number, data in incomplete set will be discarded.</li>
</ul>
<p>NOTE: Currently, the procedure of judging trigger is adjusted to DAQ sequence of LST. But it may change. A change of trigger sequence may require modification of event building procedure. At this moment, the trigger number check procedure takes into account the discrepancy of trigger number following the readout sequence of FEB as below.</p>
<ol type="1">
<li>There are two kinds of numbers, trigger number and event number, which are counted up in a FEB. Trigger number counts up when a trigger is accepted. And Event number counts up when data is extracted. Event number cannot be larger than trigger number, because of this order of counting up.</li>
<li>There is a case that FEB accepts trigger but fails to extract data because DRS4 is busy.<br />
 This case can happen when the time from previous trigger hasn't passed enough long and is still within the dead time. As a result, until the dead time ends the next data cannot be extracted and trigger number will keep counting up. Therefore the data from the FEB will show skip of trigger number. When event building, this can be seen as larger number than ones from other FEBs.<ol type="a">
<li>There can be a case that a FEB drops a trigger.<br />
 The event building will result in trouble because all the subsequent data from corresponding FEB will have shifted trigger number. To avoid this incident, artificial dead time is set in TIB(Trigger Interface Board) which distributes trigger signal to FEB. And additionally, a set of time stamps, 1PPS(1 pulse per second) and 10 MHz signal will be embedded in data to confirm that the time FEB accepted the trigger is the same. The check sequence is not implemented now.</li>
</ol>
</li>
</ol>
<h2><a class="anchor" id="BLD_SUBMITSUMMARY"></a>
Submit summary of DAQ</h2>
<p>Tell <a class="el" href="class_l_s_t_d_a_q_1_1_d_a_qtimer.html">LSTDAQ::DAQtimer</a> object to make summary of DAQ measurement.</p>
<h2><a class="anchor" id="BLD_RB_DATAUNLOAD"></a>
Unload remaining data from RingBuffer</h2>
<p>Continue <a class="el" href="class_l_s_t_d_a_q_1_1_ring_buffer.html#a589fb1045d27590cca235e01f313d1e8" title="The function to read data from RingBuffer. ">LSTDAQ::RingBuffer::read()</a> until all the data in RingBuffer is regarded as read.</p>
<h2><a class="anchor" id="COLL_THREADEND"></a>
Thread ends.</h2>

</div>
</div>
<a class="anchor" id="a568c34b708bcc89579bda6142733110a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* Collector_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collector_thread Collects data from FEBs by TCP/IP connection and stores it to RingBuffer. </p>
<h1><a class="anchor" id="COLL_PROC"></a>
Procedures</h1>
<ol type="1">
<li>Sets the first charged <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> .</li>
<li>Sets CPU.</li>
<li>Searches the charged <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> structs</li>
<li>Establishes TCP/IP connections with FEBs.</li>
<li>Synchronizes with all threads before starting DAQ.</li>
<li>Reads data from socket<br />
 and writes it to RingBuffer.</li>
<li>Goes out the loop.</li>
<li>Thread ends.</li>
</ol>
<h2><a class="anchor" id="COLL_SETFIRST"></a>
Sets the first charged sRingBuffer .</h2>
<p>This function receives reference to an <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> struct as void* type, and casts it as "sRingBuffer" struct. <br />
 From Cid in it, this thread knows its Collector ID. This struct is the first one among which this thread is charged for. All the struct to take charge is to be searched in <a class="el" href="_master_8cpp.html#COLL_SEARCHRB">Search the charged sRingBuffer structs</a> .</p>
<h2><a class="anchor" id="COLL_SETCPU"></a>
Sets CPU</h2>
<p>Sets CPU. See <a class="el" href="index.html#CPU_ID">CPU ID specification</a> .</p>
<h2><a class="anchor" id="COLL_SEARCHRB"></a>
Search the charged sRingBuffer structs</h2>
<p>Searches all the structs for connections for which this thread is assigned.</p>
<h2><a class="anchor" id="COLL_TCPCON"></a>
Establishes TCP/IP connections with FEBs.</h2>
<p>Establishes TCP/IP connections with FEBs. <a class="el" href="class_l_s_t_d_a_q_1_1_l_i_b_1_1_t_c_p_client_socket.html" title="The class to take care of TCP/IP connection. ">LSTDAQ::LIB::TCPClientSocket()</a> takes main role.</p>
<h2><a class="anchor" id="COLL_STARTSYNC"></a>
Synchronizes threads before starting DAQ.</h2>
<p>Waits for the other threads to be prepared as well. See <a class="el" href="index.html#START_SYNC">Start synchronization</a>.</p>
<h2><a class="anchor" id="COLL_READSOCK"></a>
Reads data from socket and writes it to RingBuffer.</h2>
<p>Reads data arrived at the sockets and writes on Ring Buffers (in the structs). Reading from sockets is performed by <a class="el" href="class_l_s_t_d_a_q_1_1_l_i_b_1_1_t_c_p_client_socket.html" title="The class to take care of TCP/IP connection. ">LSTDAQ::LIB::TCPClientSocket()</a> and writing to Ring Buffers is performed by <a class="el" href="class_l_s_t_d_a_q_1_1_ring_buffer.html#a6e5dd48d737d2a7cdc8e53baa97900eb" title="The function to write data on RingBuffer in which wbytes[bytes] of data from *buf will be written...">LSTDAQ::RingBuffer::write()</a>.</p>
<h2><a class="anchor" id="COLL_OUTLOOP"></a>
Goes out the loop.</h2>
<p>Goes out the loop when read amount of all the connections exceeded the requested amount.</p>
<h2><a class="anchor" id="COLL_THREADEND"></a>
Thread ends.</h2>

</div>
</div>
<a class="anchor" id="a5cb25131ecbe5f55819aa31d331c833a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getMaxCid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0173e926c090810e7a7f5cd30356192c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void inverseByteOrder </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the byte order of given array. </p>
<p>The order of each value inside data sent from Dragon is inversed.<br />
 For event building, trigNo and evtNo are needed.<br />
 This function is used to flip byte orders of them after extraction of data from socket.<br />
 </p>

</div>
</div>
<a class="anchor" id="a3c04138a5bfe5d72780bb7e82a18e627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int main </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>main </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">infreq</td><td>Input frequency. (i.e.the frequency of triggers which are given to FEB.)<br />
 specified by argv[1].<br />
 This is used only for making report. </td></tr>
    <tr><td class="paramname">Ndaq</td><td>The number of events to acquire.<br />
 specified by argv[2], otherwise DAQ_NEVENT is set.</td></tr>
    <tr><td class="paramname">datacreate</td><td>Whether data will be saved. specified by argv[3]. If yes, data is saved to disk.</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="MAIN_PROC"></a>
The procedures</h1>
<ol type="1">
<li>Set parameters from args</li>
<li>Inspect # of CPUs</li>
<li>Read configuration file and check its validity.</li>
<li>Set configurations for thread and connection in sRIngBuffer structs.</li>
<li>submit Multi-threaded processes</li>
<li>wait all the Multi-threaded processes to finish</li>
</ol>
<h2><a class="anchor" id="MAIN_SET_PARAM"></a>
Set parameters from args</h2>
<p>At submission, main function can receive 1 to 3 arguments. The arg[] are set as follows.<br />
 Ndaq = arg[1]<br />
 infreq = arg[2]<br />
 datacreate = arg[3]<br />
</p>
<h2><a class="anchor" id="MAIN_INS_CPU"></a>
Inspect # of CPUs</h2>
<p>Ncpu is set from sysconf(). see <a class="el" href="index.html#CPU_ID">CPU ID specification</a> .</p>
<h2><a class="anchor" id="MAIN_READCONF"></a>
Read configuration file and check its validity.</h2>
<p>Read "Connection.conf" in which empty lines and lines start with "#" are neglected.</p><ul>
<li>Parameters to be set<br />
<ul>
<li>Below are used to store the values read from "Connection.conf" temporally .<ul>
<li>shCid : Collector id.</li>
<li>szAddr : IP address of FEB.</li>
<li>shPort : Port number of FEB.</li>
</ul>
</li>
<li>Below are set from the values above.<ul>
<li>maxCid : The maximum value of Collector ID.</li>
<li>firstRB: The first connection ID for each collector thread.</li>
</ul>
</li>
</ul>
</li>
<li>Restrictions<br />
 There is a rule below for writing configuration files. If the values above violates it, the program exits.<ul>
<li>Limit of # of connections<br />
 If more connections than MAX_CONNECTION are written in "Connection.conf", program exits.</li>
<li>No skip of Cid<br />
 If there is interval in Cid specification, program exits.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="MAIN_SETSRB"></a>
Set configurations for thread and connection in sRIngBuffer structs.</h2>
<ul>
<li>After validation, The parameters below are set to <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> structs from the parameters above.<ul>
<li>sRB.Cid</li>
<li>sRB.szAddr</li>
<li>sRB.shPort</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="MAIN_SUBMIT"></a>
Submit Multi-threaded processes</h2>
<p>By pthread_create() function, threads are created. handle[] is an array of pthread_t type variable, which is used to handle threads. By their numbers the array, threads are numbered as these.<br />
 </p><table class="doxtable">
<tr>
<th>Thread name </th><th>Number of threads </th><th>handle[]  </th></tr>
<tr>
<td>Collector_thread </td><td>nColl </td><td>0 - nColl-1 </td></tr>
<tr>
<td>Builder_thread </td><td>1 </td><td>nColl </td></tr>
<tr>
<td>ThruPutMes_thread</td><td>1 </td><td>nColl+1 </td></tr>
</table>
<p>Note:<br />
Which <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> a collector thread take charge of is defined by creating the tread giving the first <a class="el" href="structs_ring_buffer.html">sRingBuffer</a> struct to be treated by it.</p>
<h2><a class="anchor" id="MAIN_JOIN"></a>
wait all the Multi-threaded processes to finish</h2>
<p>pthread_join() function waits for a thread to end. When all the threads finished, this function ends. </p>

</div>
</div>
<a class="anchor" id="a2bc96e14aff905cfba14c80aa9fc6bc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sRBcreate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nServ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6d162cd44c490ccae81ac5d22f7db74a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sRBdelete </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nServ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdfe90600cb22da97e4a38a3a7245c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sRBinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add67bfd9f7cbc6a394d0d61a41e57ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sRBsetaddr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sRBid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>shCid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>szAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>shPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9138383c988375a04ce17786819665e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ThruPutMes_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ThruPutMes thread. </p>

</div>
</div>
<a class="anchor" id="aa7b0d9ec5f71e9be9d0520a7f862a486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usage </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ae415d43f6dfaf58e6bca992b143ac004"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t cond_allend =PTHREAD_COND_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e4fa43841449af20dd3798e7de87d2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool datacreate</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a44ff404ab6caa6e80830e799d22120a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int infreq</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4ae5c06802ed8788fbd5a7d55d9c5b85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int initEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a898fdbfa9c296c6a8e343c764f11acba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t mutex_initLock =PTHREAD_MUTEX_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a601520f53e2d3d67744513d176ccf90a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ncpu</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a80ca370ae9c3da6cf6d5e75206dfb76d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Ndaq</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa65708d975d0c62e4d1edb504fa5ba2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structs_ring_buffer.html">sRingBuffer</a> sRB[<a class="el" href="_config_8hpp.html#a17300200b36fc0300d37054428db318b">MAX_RINGBUF</a>]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
