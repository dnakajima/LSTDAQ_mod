<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>LSTDAQ: LSTDAQ ver3.0</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LSTDAQ
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespaceLSTDAQ.html">LSTDAQ</a> ver3.0 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Kazuma Ishio,Daisuke Nakajima Univ. of Tokyo </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Last modified on 2016/05/02</dd></dl>
<h1><a class="anchor" id="INTRO"></a>
Introduction</h1>
<p>LSTDAQ is a program to perform data acquisition from LST camera.<br />
 The camera in a telescope consists of 265 modules called FEB. LSTDAQ acquires data from them through TCP/IP connection.<br />
 At this moment minimum features are implemented.</p>
<h2><a class="anchor" id="FUNCTIONALITY_OVERVIEW"></a>
Functionality Overview</h2>
<ul>
<li>TCP/IP connection to FEBs (configurable without compilation)</li>
<li>Multi threaded data acquisition through TCP/IP (configurable without compilation)</li>
<li>Event building identifying trigger number</li>
<li>data pooling in ring buffers, to absorb inequality of sending data between FEBs.</li>
</ul>
<h2><a class="anchor" id="PROC_OVERVIEW"></a>
Procedure Overview</h2>
<ul>
<li><a class="el" href="Master_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title="main ">main()</a> function<ul>
<li>Sets parameters from args and sysconf.</li>
<li>Reads configuration file.</li>
<li>Creates structs for connetions.</li>
<li>Creates Builder thread.</li>
<li>Creates Collector threads.</li>
<li>Creates Monitor thread.</li>
<li>Waits for the end of the threads.</li>
</ul>
</li>
<li><a class="el" href="Master_8cpp.html#a568c34b708bcc89579bda6142733110a" title="Collector_thread Collects data from FEBs by TCP/IP connection and stores it to RingBuffer. ">Collector_thread()</a> function<ul>
<li>Casts the input</li>
<li>Sets CPU.</li>
<li>Searches the charged <a class="el" href="structsRingBuffer.html">sRingBuffer</a> structs</li>
<li>Establishes TCP/IP connections with FEBs.</li>
<li>Synchronizes threads before starting DAQ.</li>
<li>Reads data from socket<br />
 and writes it to RingBuffer.</li>
<li>Goes out the loop.</li>
<li>Thread ends.</li>
</ul>
</li>
<li><a class="el" href="Master_8cpp.html#a435b26afa480ba18cbef3620d0eccee2" title="Builder_thread Performs event building in which data is collected from all RingBuffers by event wise ...">Builder_thread()</a> function<ul>
<li>Receives the first struct for connection.</li>
<li>Searches all the structs for connections</li>
<li>Sets CPU.</li>
<li>Creates output file.</li>
<li>Waits for start synchronization.</li>
<li>Reads data written in Ring Buffers by Collector threads, combining the data with identical trigger number embedded in the data.</li>
<li>Goes out the loop when read amount of one of the connections exceeded the requested amount.</li>
<li>Thread ends.</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="PROCEDURE_CLOSEVIEW"></a>
Common procedure closeview</h1>
<p>In this section, the explanation for the procedures which are commonly used are provided.</p>
<h2><a class="anchor" id="CPU_ID"></a>
CPU ID specification</h2>
<p>To adopt parallel computing, assigned are CPU IDs to the threads, which are divided in a unit of procedue which can run in parallel.</p>
<h3><a class="anchor" id="CPU_ID_OVERVIEW"></a>
Overview</h3>
<p>main function creates multi threads. The threads consist of one ThruPutMes_thread, one Builder_thread and several Collector_thread. Collector_thread can run as multiple threads and the configuration of multiplicity is established by reading Connection.conf. The number of threads can be increased without limit. But the number of CPUs is limited, therefore too many threads cause assignment of the CPUs shared by multiple threads. Unless the number of threads does not exceed the number of CPUs, assignment of threads to CPUs is done avoiding biased assignment.</p>
<h3><a class="anchor" id="CPU_ID_PROC"></a>
Procedues</h3>
<p>There are <code>nColl + 2</code> threads to be assigned, which consist of one <code>Builder_thread</code>, one <code>ThruPutMes_thread</code>, and <code>nColl</code> threads of <code>Collector_thread</code>. Using residual number, CPUs are assigned to the threads evenly. Here is the relation between thread and <code>CPU_ID</code>.</p>
<table class="doxtable">
<tr>
<th>Thread name </th><th>Number of threads </th><th>CPU ID  </th></tr>
<tr>
<td>Collector_thread </td><td><code>nColl</code> </td><td><code>Cid</code> % <code>Ncpu</code> (where <code>Cid</code> = 0,1,2...<code>nColl</code>-1) </td></tr>
<tr>
<td>Builder_thread </td><td>1 </td><td><code>nColl</code> % <code>Ncpu</code> </td></tr>
<tr>
<td>ThruPutMes_thread</td><td>1 </td><td><code>nColl</code>+1 % <code>Ncpu</code> </td></tr>
</table>
<p>The number of CPUs is inspected using <code>sysconf()</code> function in <code><a class="el" href="Master_8cpp.html#a3c04138a5bfe5d72780bb7e82a18e627" title="main ">main()</a></code> function, and stored as <code>Ncpu</code> value. When a thread starts, which CPU to use is set, specifying <code>CPU_ID</code> in <code>__CPU_SET()</code> function.</p>
<h2><a class="anchor" id="START_SYNC"></a>
Start synchronization</h2>
<p>When DAQ starts, all the Collector_thread and Builder_thread synchronize, not to waste Ring Buffer memory in a way that Collector_thread starts filling data in Ring Buffer before Builder_thread gets prepared to extract it.</p>
<h3><a class="anchor" id="START_SYNC_DETAILS"></a>
Procedures</h3>
<ul>
<li>When Builder_thread gets prepared, it waits all the other threads untill they are also prepared, checking if <code>initEnd</code> become nColl (BLD_START_SYNC process).</li>
<li>On the other hand, Collector_threads undergo the preparation process too. In a Collector_thread, when it has established connection with all the charged FEBs, it increases <code>initEnd</code> value by 1, stops itself, and waits for Builder_thread to call it.</li>
<li>When all Collector_threads get prepared (<code>initEnd</code> = <code>nColl</code>), Builder_thread broadcasts the allowance of starting DAQ to all Collector_threads.</li>
<li>Builder_thread starts reading data from RingBuffers immediately after the announcement, while a Collector_thread starts reading data from socket and writing data to RingBuffer after it notices the announcement.</li>
</ul>
<h3><a class="anchor" id="START_SYNC_PTHREAD"></a>
Implementation</h3>
<p>This functionality is implemented using <code>mutex_initLock</code> as a <code>pthread_mutex_t</code> and <code>cond_allend</code> as a <code>pthread_cond_t</code>.</p>
<ul>
<li>Collector_thread<br />
 When a Collector_thread gets prepared for DAQ, it locks <code>mutex_initLock</code> ticket by <code>pthread_mutex_lock()</code> and immediately it releases it by <code>pthread_cond_wait()</code>. But this function makes it stopped until <code>pthread_cond_broadcast()</code> is issued to <code>cond_allend</code>. After receiving the signal, it again tries to lock <code>mutex_initLock</code> which enables it to leave <code>pthread_cond_wait()</code> function. As the last step, now having the <code>mutex_initLock</code> ticket, it unlocks it by <code>pthread_mutex_unlock()</code> so that the other Collector_threads can do the same step.</li>
<li>Builder_thread<br />
 When <code>initEnd</code> = <code>nColl</code>, Builder_thread announces the allowance of starting DAQ as follows. First, it locks <code>mutex_initLock</code> which is already free from any other threads, with pthread_mutex_lock() method. Second, it sends signal to all the threads which have issued <code>pthread_cond_wait()</code> function with <code>cond_allend</code> variable. This procedure means that it announces the start of DAQ to all the Collector_threads. At last, it unlocks <code>mutex_initLock</code> with <code>pthread_mutex_unlock()</code> function for the Collector_threads to be able to leave <code>pthread_cond_wait()</code> function.</li>
<li>ThruPutMes_thread<br />
 When preparation for the measurement is completed, it does the same steps as Builder_thread. But the steps neither do nor suffer from any harm. Here is the inspection of two possible case:<ul>
<li>Earlier than Builder_thread<br />
 If ThruPutMes_thread precedes Builder_thread, ThruPutMes_thread serves the <code>cond_allend</code> signal to Collector_threads. Builder_thread can also take <code>mutex_initLock</code> ticket right after some other thread releases it. This doesn't take much time because all the threads releases it (by <code>pthread_mutex_unlock()</code>) immediately after it locks (as awaking <code>pthread_cond_wait()</code>). When Builder_thread takes <code>mutex_initLock</code> and sends signal by <code>pthread_cond_broadcast()</code>, nothing happens, because the signal was already sent and all the threads have gone to next step. The moment Builder_thread releases <code>mutex_initLock</code> as the next step and starts reading RingBuffers is not so much later than</li>
</ul>
</li>
<li>A thread which will be added in the future<ul>
<li>Monitor thread </li>
</ul>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
